<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Boot Sector Revisited · x86NITC Docs</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="In Stage 3 of eXpOS, we learnt about the ROM code in page 0 of the memory and how XSM loads the OS startup code and runs it. Also recall how we were provided with an interface (xfs-interface) in order to load files easily into the disk (disk.xfs). However for x86, we do not have access to any such interfaces for now. The disk and its contents will have to be manually formatted and created by us."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Boot Sector Revisited · x86NITC Docs"/><meta property="og:type" content="website"/><meta property="og:url" content="https://x86nitc.github.io/"/><meta property="og:description" content="In Stage 3 of eXpOS, we learnt about the ROM code in page 0 of the memory and how XSM loads the OS startup code and runs it. Also recall how we were provided with an interface (xfs-interface) in order to load files easily into the disk (disk.xfs). However for x86, we do not have access to any such interfaces for now. The disk and its contents will have to be manually formatted and created by us."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><h2 class="headerTitle">x86NITC Docs</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"></ul></nav></div></header></div></div><div class="navPusher singleRowMobileNav"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Getting Started</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Setting up your Machine<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/setup">Installing a CPU Emulator</a></li><li class="navListItem"><a class="navItem" href="/notes">A Note from your seniors</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Getting Started<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/boot">Boot Sector Revisited</a></li><li class="navListItem"><a class="navItem" href="/makefile">Using Makefile for Builds</a></li><li class="navListItem"><a class="navItem" href="/print16">Printing to Screen</a></li><li class="navListItem"><a class="navItem" href="/address-org">Boot Code Memory Offset</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">The Real Mode<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/intro-real-mode">Introduction to the Real Mode</a></li><li class="navListItem"><a class="navItem" href="/segmentation">Memory Organisation and Setting up Stack</a></li><li class="navListItem"><a class="navItem" href="/load-disk">Loading Disk Blocks to Memory</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Switching to the Protected Mode<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/intro-protected-mode">Introduction to the Protected Mode</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Setting up a screen driver<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/io-intro">Introduction to I/O Addressing</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Boot Sector Revisited</h1></header><article><div><span><p>In Stage 3 of eXpOS, we learnt about the ROM code in page 0 of the memory and how XSM loads the OS startup code and runs it. Also recall how we were provided with an interface (xfs-interface) in order to load files easily into the disk (disk.xfs). However for x86, we do not have access to any such interfaces for now. The disk and its contents will have to be manually formatted and created by us.</p>
<p>x86 architecture expects the bootstrap code in block 0 of the disk. Now on a modern system, there could be multiple disks attached to the motherboard. This could be USB drives, hard disks, floppy disks etc. We then specify a boot order list in BIOS and the machine boots from the first disk on that list that is found to be bootable, skipping through the others that are not. In XSM, the architecture was restricted to a single disk at a time and hence the dilemma of which disk to boot from was not faced.</p>
<p>So how does the machine know whether a particular disk is bootable or not? This is where the boot flag comes. Any disk with block 0 having bootable code for x86 must hence have a boot flag (0xaa55) appended in the end. This lets x86 know that the particular disk is bootable.</p>
<p>In eXpOS, we loaded a small program which printed &quot;HELLO WORLD&quot;. However we cannot do the same for our x86 operating system yet. This is because we are not aware of the port mappings in x86 yet. So in this stage we shall simply write a code that jumps into an infinite loop. This code will then be appended with empty content (zeroes) and have the boot flag in the end so as to make the entire binary in the end 512 bytes large. This is done as blocks are 512 bytes long in the x86 architecture.</p>
<p class="codeblock-label">boot.asm</p>
<pre><code class="hljs"><span class="hljs-keyword">jmp</span> $ <span class="hljs-comment">; Infinite loop to current instruction</span>

<span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span> <span class="hljs-comment">; Fill the remaining 510 bytes with zeroes </span>
<span class="hljs-built_in">dw</span> <span class="hljs-number">0xaa55</span> <span class="hljs-comment">; 2 bytes containing the boot flag</span>
</code></pre>
<p>This code is compiled using <code>nasm</code>. Run <code>nasm -f bin boot.asm -o boot.bin</code>
You can then run the code using <code>qemu-system-i386 -hda boot.bin</code>
The <code>-hda</code> option specifies to use our compiled binary as a hard disk into the emulator.</p>
<p>You should expect to see a screen that is seemingly stuck after a <code>Booting from Hard Disk...</code> message.</p>
<p>Since the project will get increasingly complex as we progress, it is desired to have some code files organisation in our project directory. We shall hence put all our boot related files in a <code>boot/</code> directory. Create a new directory named <code>boot/</code> and move the boot.asm file inside it.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/notes"><span class="arrow-prev">← </span><span>A Note from your seniors</span></a><a class="docs-next button" href="/makefile"><span>Using Makefile for Builds</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div></div></body></html>