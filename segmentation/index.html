<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Memory Organisation and Setting up Stack · x86NITC Docs</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="This chapter is very vaguely written. The aim is simply to introduce the idea of memory segmentation. While one will definitely develop better clarity on the idea in further stages, if you feel you must absolutely understand the concept better before you can proceed, you can refer the Intel 80386 Programmer&#x27;s Reference Manual Chapter 5. It is, however, advised to not refer it right now as it is not required presently."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Memory Organisation and Setting up Stack · x86NITC Docs"/><meta property="og:type" content="website"/><meta property="og:url" content="https://x86nitc.github.io/"/><meta property="og:description" content="This chapter is very vaguely written. The aim is simply to introduce the idea of memory segmentation. While one will definitely develop better clarity on the idea in further stages, if you feel you must absolutely understand the concept better before you can proceed, you can refer the Intel 80386 Programmer&#x27;s Reference Manual Chapter 5. It is, however, advised to not refer it right now as it is not required presently."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><h2 class="headerTitle">x86NITC Docs</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"></ul></nav></div></header></div></div><div class="navPusher singleRowMobileNav"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>The Real Mode</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Setting up your Machine<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/setup">Installing a CPU Emulator</a></li><li class="navListItem"><a class="navItem" href="/notes">A Note from your seniors</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Getting Started<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/boot">Boot Sector Revisited</a></li><li class="navListItem"><a class="navItem" href="/makefile">Using Makefile for Builds</a></li><li class="navListItem"><a class="navItem" href="/print16">Printing to Screen</a></li><li class="navListItem"><a class="navItem" href="/address-org">Boot Code Memory Offset</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">The Real Mode<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/intro-real-mode">Introduction to the Real Mode</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/segmentation">Memory Organisation and Setting up Stack</a></li><li class="navListItem"><a class="navItem" href="/load-disk">Loading Disk Blocks to Memory</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Switching to the Protected Mode<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/intro-protected-mode">Introduction to the Protected Mode</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Setting up a screen driver<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/io-intro">Introduction to I/O Addressing</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Memory Organisation and Setting up Stack</h1></header><article><div><span><p>This chapter is very vaguely written. The aim is simply to introduce the idea of memory segmentation. While one will definitely develop better clarity on the idea in further stages, if you feel you must absolutely understand the concept better before you can proceed, you can refer the Intel 80386 Programmer's Reference Manual Chapter 5. It is, however, advised to not refer it right now as it is not required presently.</p>
<p>The x86 allows the system-software designers to choose different models of memory segmentation. The different models were discussed in your Operating Systems theory course. There are two memory organisation schemes discussed in the Intel 80386 Programmer's Reference Manual. These are the flat model and the segmented model.</p>
<p>In the flat model, the logical memory is seen as a flat space by the application developers i.e. a single stretch of linear addresses. As the addressing in 80386 is 32-bit, A maximum of 2<sup>32</sup> bytes RAM can be addressed (4 GB). Note that it is not necessary that this logical address space from 0 to 2<sup>32</sup>-1 need not actually be contiguous in the physical address space. The logical to physical address mapping is upto the system-software designer and application designers need not know about them.</p>
<p>A second organisation model and the one we will be using for our project is the segmented model. In this model, the memory as seen by the application programmers as segments of upto 4 GB each. There can be upto 16.383 segments of linear addresses. Again, all address mapping to the actual physical address space is kept unknown to the application developers.</p>
<p>The above descriptions on the models are very brief and it is possible to not be yet solid on its working. However, we shall not go into detail of memory organisation models and the advantage of one model over the other. It is not necessary for you to know the same either for now. All that is required to understand is how x86 offers support for a segmented memory model where you can place your application's code and instructions in one segment, data in another segment, stack in another and so on. There are various registers such as CS (Code Segment Register), DS (Data Segment Register), SS (Stack Segment Register), ES (Extra Segment Register) etc. that enable this. The x86 automatically translates the addresses in an instruction with the correct segment according to the address type. For example, all instructions (IP) will be fetched from the Code Segment while all references to the register SP (Stack Pointer) will use the Stack Segment and all memory data references will use the Data Segment. The CS, DS, SS, ES are all 16-bit registers. ith a segmented model, all corresponding address references in the code is simply the offset in the respective segment. In addition the actual translation is not done by simply appending the offset address to the segment address but by merging them as <code>(segment_address &lt;&lt; 4) + offset</code>. The idea will become clearer with further stages.</p>
<p>When the CPU is RESET (powered on), all the segment registers are initialised to zero (0x0). We shall now initialize a stack by setting the value of the register <code>sp</code>. Simply add lines <code>mov bp, 0x9000</code> and <code>mov sp, bp</code> to initialize our real mode stack frame and top of stack to the address <code>0x9000</code>. The actual address for stack operations now will be (0x0 &lt;&lt; 4 + 0x9000 = 0x9000).</p>
<p class="codeblock-label">boot/boot.asm</p>
<pre><code class="hljs">[org <span class="hljs-number">0x7c00</span>]

<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, MSG_REAL_MODE
<span class="hljs-keyword">call</span> print_string

<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bp</span>, <span class="hljs-number">0x9000</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-built_in">bp</span>

<span class="hljs-keyword">jmp</span> $

<span class="hljs-meta">%include</span> <span class="hljs-string">"boot/print_string.asm"</span>

MSG_REAL_MODE <span class="hljs-built_in">db</span> <span class="hljs-string">"Entered 16 bit Real Mode"</span>, <span class="hljs-number">0</span>

<span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span>
<span class="hljs-built_in">dw</span> <span class="hljs-number">0xaa55</span>
</code></pre>
<p>Recall that a stack grows downwards. Hence in our case, upon using the push command once, the stack top is updated to 0x8ffe (2 bytes downwards). The reason for the two bytes is that we have a 16-bit stack and not an 8-bit one and hence all push and pop instruction deals with 2 bytes (16-bits) at once. You can test the same as follows:</p>
<p class="codeblock-label">boot/example.asm</p>
<pre><code class="hljs"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bp</span>, <span class="hljs-number">0x9000</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-built_in">bp</span>

<span class="hljs-keyword">push</span> <span class="hljs-string">'A'</span>
<span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x0e</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-number">0x8ffe</span>] <span class="hljs-comment">; -2 due to 16-bit stack</span>
<span class="hljs-keyword">int</span> <span class="hljs-number">0x10</span>

<span class="hljs-keyword">jmp</span> $

<span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span>
<span class="hljs-built_in">dw</span> <span class="hljs-number">0xaa55</span>
</code></pre>
<p>Run the above code by compiling with <code>nasm -f bin -o example boot/example.asm</code> and running with QEMU <code>qemu-system-i386 -hda example</code>
We will also look at an example for understanding segmentation. We will attempt to store two characters in the same offset but in two different segments one starting at 0x0 and the other at 0x1000 and try to access them.</p>
<p class="codeblock-label">boot/example.asm</p>
<pre><code class="hljs"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bp</span>, <span class="hljs-number">0x9000</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-built_in">bp</span>
<span class="hljs-keyword">push</span> <span class="hljs-string">'A'</span> <span class="hljs-comment">; Stored at (0x0 + 0x8ffe)</span>

<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">0x100</span> <span class="hljs-comment">; Segment addresses are shifted automatically &lt;&lt; 4 (i.e. 0x1000)</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">bx</span> <span class="hljs-comment">; Since x86 does not allow storing immediate values </span>
           <span class="hljs-comment">; directly to segment registers, we use bx here</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x9000</span> <span class="hljs-comment">; Resetting stack top to 0x9000</span>
<span class="hljs-keyword">push</span> <span class="hljs-string">'B'</span> <span class="hljs-comment">; Stored at (0x1000 + 0x8ffe)</span>

<span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x0e</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-number">0x8ffe</span>] <span class="hljs-comment">; A memory reference implicitly uses data segment value</span>
                 <span class="hljs-comment">; and DS initialises to 0x0</span>
<span class="hljs-keyword">int</span> <span class="hljs-number">0x10</span>

<span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">ss</span>:<span class="hljs-number">0x8ffe</span>] <span class="hljs-comment">; Explicitly using a different segment for the address</span>
<span class="hljs-keyword">int</span> <span class="hljs-number">0x10</span>

<span class="hljs-keyword">jmp</span> $
<span class="hljs-symbol">
character:</span> <span class="hljs-built_in">db</span> <span class="hljs-string">'B'</span>
<span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span>
<span class="hljs-built_in">dw</span> <span class="hljs-number">0xaa55</span>
</code></pre>
<p>After understanding the above examples, remove the example.asm file from the <code>boot/</code> directory.</p>
<p>Now that we have set up our stack, let us modify the print_string function to save the value of ax before operating with it and restore it before returning</p>
<p class="codeblock-label">boot/print_string.asm</p>
<pre><code class="hljs"><span class="hljs-symbol">print_string:</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span> <span class="hljs-comment">; Save ax register</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x0e</span> <span class="hljs-comment">; Specify the function to use i.e. print al to tty</span>
<span class="hljs-symbol">    print:</span>
        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">bx</span>]
        <span class="hljs-keyword">int</span> <span class="hljs-number">0x10</span>
        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span>
        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0</span>
        <span class="hljs-keyword">je</span> return
        <span class="hljs-keyword">jmp</span> print
<span class="hljs-symbol">    return:</span>
    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span> <span class="hljs-comment">; Restore ax register</span>
    <span class="hljs-keyword">ret</span>
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/intro-real-mode"><span class="arrow-prev">← </span><span>Introduction to the Real Mode</span></a><a class="docs-next button" href="/load-disk"><span>Loading Disk Blocks to Memory</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div></div></body></html>